package construction;

import java.util.HashSet;

import general.Node;
import general.Print;

public class Preorder_And_Preorder_Of_Mirror_To_Binary_Tree {
	public static void main(String[] args) {
		int[] pre = {1,2,4,5,3,6,7};
        int[] mirrorPre = {1,3,7,6,2,5,4};
        Print.print(construct(pre, mirrorPre));
	}

	public static Node construct(int[] pre, int[] mirrorPre) {
		Node root = new Node(pre[0]);
		Node node = root;
		HashSet<Integer> set = new HashSet<Integer>();
		set.add(pre[0]);
		int preIndex = 0, mirrorPreIndex;
		while (preIndex < pre.length) {
			if (set.contains(pre[preIndex])) {
				preIndex++;
			}
			else {
				mirrorPreIndex = find(mirrorPre, pre[preIndex]);
				
				if (preIndex + 1 < pre.length && !set.contains(pre[preIndex + 1])) {
					node.left = new Node(pre[preIndex + 1]);
					set.add(pre[preIndex + 1]);
				}
				if (mirrorPreIndex + 1 < mirrorPre.length && !set.contains(mirrorPre[mirrorPreIndex + 1])) {
					node.right = new Node(mirrorPre[mirrorPreIndex + 1]);
					set.add(mirrorPre[mirrorPreIndex + 1]);
				}
				preIndex++;
			}
		}
		return root;
	}
	
	public static int find(int[] mirrorpre, int find) {
		for (int i = 0; i < mirrorpre.length; i++) {
			if (mirrorpre[i] == find) return i;
		}
		return -1;
	}
}
