package construction;

import java.util.HashSet;

import general.Node;
import general.Print;

public class Preorder_And_Preorder_Of_Mirror_To_Binary_Tree {
	public static void main(String[] args) {
		int[] pre = {1,2,4,5,3,6,7};
        int[] mirrorPre = {1,3,7,6,2,5,4};
        Print.print(construct(pre, mirrorPre));
	}
	static int preIndex;
	static Node constructTree(int pre[], int preMirror[]) {
		preIndex = 0;
		int[] preMirror1 = new int[pre.length];
		for (int i = pre.length - 1; i >= 0; i--) {
			preMirror1[pre.length - 1 - i] = preMirror[i];
		}
		return constructTreeUtil(pre, preMirror1, 0, pre.length - 1, pre.length);
	}
	
	static Node constructTreeUtil(int pre[], int post[], int l, int h, int size) {
		if (preIndex >= size || l > h) return null;
		Node root = new Node(pre[preIndex++]);
		if (l == h || preIndex >= size) return root;
		int i;
		for (i = l; i <= h; i++) {
			if (post[i] == pre[preIndex]) break;
		}
		if (i <= h) {
			root.left = constructTreeUtil(pre, post, l, i, size);
			root.right = constructTreeUtil(pre, post, i + 1, h, size);
		}
		return root;
	}		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	public static Node construct(int[] pre, int[] mirrorPre) {
		Node root = new Node(pre[0]);
		Node node = root;
		HashSet<Integer> set = new HashSet<Integer>();
		set.add(pre[0]);
		int preIndex = 0, mirrorPreIndex;
		while (preIndex < pre.length) {
			if (set.contains(pre[preIndex])) {
				preIndex++;
			}
			else {
				mirrorPreIndex = find(mirrorPre, pre[preIndex]);
				
				if (preIndex + 1 < pre.length && !set.contains(pre[preIndex + 1])) {
					node.left = new Node(pre[preIndex + 1]);
					set.add(pre[preIndex + 1]);
				}
				if (mirrorPreIndex + 1 < mirrorPre.length && !set.contains(mirrorPre[mirrorPreIndex + 1])) {
					node.right = new Node(mirrorPre[mirrorPreIndex + 1]);
					set.add(mirrorPre[mirrorPreIndex + 1]);
				}
				preIndex++;
			}
		}
		return root;
	}
	
	public static int find(int[] mirrorpre, int find) {
		for (int i = 0; i < mirrorpre.length; i++) {
			if (mirrorpre[i] == find) return i;
		}
		return -1;
	}
}
